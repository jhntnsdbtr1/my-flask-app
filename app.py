# -*- coding: utf-8 -*-
"""Model.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h4NxSukmWUYrSbZI3qMdTi3kcQYR8teD
"""

!pip install Flask pandas scikit-learn pyngrok numpy matplotlib

!pip install flask-cors

!pip install gunicorn

from flask import Flask, request, jsonify, send_file
from flask_cors import CORS  # Import CORS

app = Flask(__name__)
CORS(app)  # Mengaktifkan CORS untuk semua route

from pyngrok import ngrok

# Ganti 'YOUR_AUTH_TOKEN' dengan token yang Anda dapatkan dari akun ngrok
ngrok.set_auth_token("2vaPWpEZRhbVSwhoS6slUs9RCdX_79B8yrmVsoU5PqeWekLur")

"""ROUTES API"""

from flask import Flask, request, jsonify
import pandas as pd
import numpy as np
import os
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.model_selection import GridSearchCV
from itertools import product
from pyngrok import ngrok

app = Flask(__name__)

latest_df = None
latest_result = None
dt_model = None
rf_model = None
gb_model = None
X_used = None
y = None


def clean_data(df):
    df = df.copy()
    df.columns = df.columns.str.strip()  # Hapus spasi pada nama kolom

    required_columns = ['EARTAG', 'Jenis Kelamin', 'Usia', 'Berat', 'Kesehatan', 'RiwayatKawin']
    for col in required_columns:
        if col not in df.columns:
            raise ValueError(f"Kolom '{col}' tidak ditemukan dalam file CSV")

    def convert_age(usia):
        try:
            tahun, bulan, hari = 0, 0, 0
            if isinstance(usia, str):
                parts = usia.split(',')
                for part in parts:
                    part = part.strip().lower()
                    if 'tahun' in part:
                        tahun = int(''.join(filter(str.isdigit, part)))
                    elif 'bulan' in part:
                        bulan = int(''.join(filter(str.isdigit, part)))
                    elif 'hari' in part:
                        hari = int(''.join(filter(str.isdigit, part)))
            return tahun * 12 + bulan + (hari / 30)
        except:
            return np.nan

    df['Usia_bulan'] = df['Usia'].apply(convert_age)
    # Jika usia >= 6 bulan, set Usia jadi 1 (cukup umur kawin), else 0
    df['Usia'] = df['Usia_bulan'].apply(lambda x: 1 if x >= 6 else 0)

    def convert_health(val):
        if isinstance(val, str):
            val = val.strip().lower()
            return 1 if val == 'sehat' else 0
        return 0

    def convert_riwayat(val):
        if isinstance(val, str):
            val = val.strip().lower()
            return 1 if val == 'sudah' else 0
        return 0

    df['Kesehatan'] = df['Kesehatan'].apply(convert_health)
    df['RiwayatKawin'] = df['RiwayatKawin'].apply(convert_riwayat)

    df['Berat'] = pd.to_numeric(df['Berat'], errors='coerce')

    # Isi kolom 'Induk Jantan', 'Kakek', 'Buyut' jika kosong
    for col in ['Induk Jantan', 'Kakek', 'Buyut']:
        if col not in df.columns:
            df[col] = 'Unknown'
        else:
            df[col] = df[col].fillna('Unknown').astype(str)

    # Drop baris jika kolom penting ada yang NaN (Usia, Berat, dll)
    df.dropna(subset=required_columns, inplace=True)

    def determine_genetic(row):
        if row['Induk Jantan'] == row['Kakek'] or row['Induk Jantan'] == row['Buyut']:
            return 0
        if row['Kakek'] == row['Buyut']:
            return 0
        return 1

    df['Genetik'] = df.apply(determine_genetic, axis=1)

    def rekomendasi_kawin(row):
        # Usia cukup, sehat, dan genetik baik
        if row['Usia'] == 1 and row['Kesehatan'] == 1 and row['Genetik'] == 1:
            return 1
        return 0

    df['RekomendasiKawin'] = df.apply(rekomendasi_kawin, axis=1)

    df.reset_index(drop=True, inplace=True)
    df.drop(columns=['Usia_bulan'], inplace=True)

    return df


def train_models(X_train, y_train):
    dt = DecisionTreeClassifier(max_depth=4, min_samples_leaf=10, random_state=42).fit(X_train, y_train)
    rf = RandomForestClassifier(n_estimators=100, max_depth=4, min_samples_leaf=10, random_state=42).fit(X_train, y_train)
    gb = GradientBoostingClassifier(n_estimators=100, learning_rate=0.05, max_depth=4, min_samples_leaf=10, random_state=42).fit(X_train, y_train)
    return dt, rf, gb


def tune_rf(X_train, y_train):
    param_grid = {
        'n_estimators': [100, 150, 200],
        'max_depth': [3, 4, 5, 6],
        'min_samples_split': [2, 5, 10],
        'min_samples_leaf': [3, 5, 10]
    }
    grid = GridSearchCV(RandomForestClassifier(random_state=42), param_grid, cv=5, n_jobs=-1, scoring='accuracy')
    grid.fit(X_train, y_train)
    return grid.best_estimator_


def cek_inbreeding(row, jantan, betina):
    idx_j = row['idx_jantan']
    idx_b = row['idx_betina']

    j = jantan.loc[idx_j]
    b = betina.loc[idx_b]

    # Cek jika sama eartag (sama individu)
    if j['EARTAG'] == b['EARTAG']:
        return False

    # Cek jika induk jantan sama
    if j['Induk Jantan'] == b['Induk Jantan']:
        return False

    silsilah_jantan = set([j['Induk Jantan'], j['Kakek'], j['Buyut']])
    silsilah_betina = set([b['Induk Jantan'], b['Kakek'], b['Buyut']])

    # Cek tumpang tindih silsilah
    if len(silsilah_jantan.intersection(silsilah_betina)) > 0:
        return False

    # Cek hubungan silang
    if (j['Induk Jantan'] == b['Kakek']) or (b['Induk Jantan'] == j['Kakek']):
        return False

    return True


def rekomendasi(file_path, max_results=20):
    global latest_df, latest_result, dt_model, rf_model, gb_model, X_used, y

    df = pd.read_csv(file_path)
    df = clean_data(df)

    jantan = df[df['Jenis Kelamin'].str.lower() == 'jantan'].reset_index(drop=True)
    betina = df[df['Jenis Kelamin'].str.lower() == 'betina'].reset_index(drop=True)

    if jantan.empty or betina.empty:
        return {'error': 'Tidak ditemukan data jantan atau betina.'}

    pasangan = pd.DataFrame(list(product(range(len(jantan)), range(len(betina)))), columns=['idx_jantan', 'idx_betina'])
    fitur = ['Usia', 'Berat', 'Genetik', 'Kesehatan']
    for f in fitur:
        pasangan[f + '_jantan'] = jantan.loc[pasangan['idx_jantan'], f].values
        pasangan[f + '_betina'] = betina.loc[pasangan['idx_betina'], f].values

    # Cek inbreeding
    pasangan['inbreeding_ok'] = pasangan.apply(lambda row: cek_inbreeding(row, jantan, betina), axis=1)

    def label_rule(row):
        if not row['inbreeding_ok']:
            return 0
        if row['Kesehatan_jantan'] != 1 or row['Kesehatan_betina'] != 1:
            return 0
        if row['Usia_jantan'] != 1 or row['Usia_betina'] != 1:
            return 0
        if row['Genetik_jantan'] != 1 or row['Genetik_betina'] != 1:
            return 0
        if abs(row['Berat_jantan'] - row['Berat_betina']) > 3:
            return 0
        return 1

    pasangan['label'] = pasangan.apply(label_rule, axis=1)

    X = pasangan[[f + '_jantan' for f in fitur] + [f + '_betina' for f in fitur]]
    y = pasangan['label']
    X_used = X

    if len(set(y)) < 2:
        return {'error': 'Data pasangan hanya mengandung 1 kelas. Tambahkan variasi data.'}

    dt, rf, gb = train_models(X, y)
    rf_model = tune_rf(X, y)

    prob_dt = dt.predict_proba(X)[:, 1]
    prob_rf = rf.predict_proba(X)[:, 1]
    prob_gb = gb.predict_proba(X)[:, 1]

    pasangan['score'] = (prob_dt * 0.35) + (prob_rf * 0.40) + (prob_gb * 0.25)

    pasangan = pasangan[pasangan['label'] == 1]
    pasangan = pasangan.sort_values(by='score', ascending=False).head(max_results).reset_index(drop=True)

    hasil = []
    for _, row in pasangan.iterrows():
        j = jantan.loc[row['idx_jantan']]
        b = betina.loc[row['idx_betina']]
        skor_inbreeding = 1 if row['inbreeding_ok'] else 0
        hasil.append({
            'Eartag_Jantan': str(j['EARTAG']),
            'WarnaEartag_Jantan': str(j.get('Warna Eartag', 'Unknown')),
            'Eartag_Betina': str(b['EARTAG']),
            'WarnaEartag_Betina': str(b.get('Warna Eartag', 'Unknown')),
            'Skor': float(round(row['score'], 4)),
            'SkorInbreeding': int(skor_inbreeding),
        })

    latest_df = df
    latest_result = hasil
    dt_model = dt
    gb_model = gb

    return hasil


@app.route('/api/rekomendasi', methods=['POST'])
def api_rekomendasi():
    if 'file' not in request.files:
        return jsonify({'error': 'File tidak ditemukan'}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'Nama file kosong'}), 400

    if not file.filename.endswith('.csv'):
        return jsonify({'error': 'File harus berformat CSV'}), 400

    filepath = os.path.join('uploads', file.filename)
    os.makedirs('uploads', exist_ok=True)

    try:
        file.save(filepath)
        print(f"File berhasil disimpan di: {filepath}")
    except Exception as e:
        print(f"Error saat menyimpan file: {str(e)}")
        return jsonify({'error': 'Gagal menyimpan file'}), 500

    try:
        result = rekomendasi(filepath)
        if isinstance(result, dict) and 'error' in result:
            return jsonify(result), 400
        return jsonify({'result': result})
    except Exception as e:
        import traceback
        print(traceback.format_exc())
        return jsonify({'error': 'Terjadi kesalahan saat proses rekomendasi'}), 500


@app.route('/get_ngrok_url', methods=['GET'])
def get_ngrok_url():
    return jsonify({'ngrok_url': public_url})


# Jalankan ngrok
public_url = ngrok.connect(5000)
print(f"âœ… URL ngrok aktif: {public_url}/api/rekomendasi", flush=True)

if __name__ == '__main__':
    app.run(port=5000)